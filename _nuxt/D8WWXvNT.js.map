{"version":3,"file":"D8WWXvNT.js","sources":["../../../../node_modules/cookie-es/dist/index.mjs","../../../../node_modules/klona/dist/index.mjs","../../../../node_modules/nuxt/dist/app/composables/cookie.js","../../../../node_modules/@nuxt/content/dist/runtime/composables/preview.js"],"sourcesContent":["function parse(str, options) {\n  if (typeof str !== \"string\") {\n    throw new TypeError(\"argument str must be a string\");\n  }\n  const obj = {};\n  const opt = options || {};\n  const dec = opt.decode || decode;\n  let index = 0;\n  while (index < str.length) {\n    const eqIdx = str.indexOf(\"=\", index);\n    if (eqIdx === -1) {\n      break;\n    }\n    let endIdx = str.indexOf(\";\", index);\n    if (endIdx === -1) {\n      endIdx = str.length;\n    } else if (endIdx < eqIdx) {\n      index = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n      continue;\n    }\n    const key = str.slice(index, eqIdx).trim();\n    if (opt?.filter && !opt?.filter(key)) {\n      index = endIdx + 1;\n      continue;\n    }\n    if (void 0 === obj[key]) {\n      let val = str.slice(eqIdx + 1, endIdx).trim();\n      if (val.codePointAt(0) === 34) {\n        val = val.slice(1, -1);\n      }\n      obj[key] = tryDecode(val, dec);\n    }\n    index = endIdx + 1;\n  }\n  return obj;\n}\nfunction decode(str) {\n  return str.includes(\"%\") ? decodeURIComponent(str) : str;\n}\nfunction tryDecode(str, decode2) {\n  try {\n    return decode2(str);\n  } catch {\n    return str;\n  }\n}\n\nconst fieldContentRegExp = /^[\\u0009\\u0020-\\u007E\\u0080-\\u00FF]+$/;\nfunction serialize(name, value, options) {\n  const opt = options || {};\n  const enc = opt.encode || encodeURIComponent;\n  if (typeof enc !== \"function\") {\n    throw new TypeError(\"option encode is invalid\");\n  }\n  if (!fieldContentRegExp.test(name)) {\n    throw new TypeError(\"argument name is invalid\");\n  }\n  const encodedValue = enc(value);\n  if (encodedValue && !fieldContentRegExp.test(encodedValue)) {\n    throw new TypeError(\"argument val is invalid\");\n  }\n  let str = name + \"=\" + encodedValue;\n  if (void 0 !== opt.maxAge && opt.maxAge !== null) {\n    const maxAge = opt.maxAge - 0;\n    if (Number.isNaN(maxAge) || !Number.isFinite(maxAge)) {\n      throw new TypeError(\"option maxAge is invalid\");\n    }\n    str += \"; Max-Age=\" + Math.floor(maxAge);\n  }\n  if (opt.domain) {\n    if (!fieldContentRegExp.test(opt.domain)) {\n      throw new TypeError(\"option domain is invalid\");\n    }\n    str += \"; Domain=\" + opt.domain;\n  }\n  if (opt.path) {\n    if (!fieldContentRegExp.test(opt.path)) {\n      throw new TypeError(\"option path is invalid\");\n    }\n    str += \"; Path=\" + opt.path;\n  }\n  if (opt.expires) {\n    if (!isDate(opt.expires) || Number.isNaN(opt.expires.valueOf())) {\n      throw new TypeError(\"option expires is invalid\");\n    }\n    str += \"; Expires=\" + opt.expires.toUTCString();\n  }\n  if (opt.httpOnly) {\n    str += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    str += \"; Secure\";\n  }\n  if (opt.priority) {\n    const priority = typeof opt.priority === \"string\" ? opt.priority.toLowerCase() : opt.priority;\n    switch (priority) {\n      case \"low\": {\n        str += \"; Priority=Low\";\n        break;\n      }\n      case \"medium\": {\n        str += \"; Priority=Medium\";\n        break;\n      }\n      case \"high\": {\n        str += \"; Priority=High\";\n        break;\n      }\n      default: {\n        throw new TypeError(\"option priority is invalid\");\n      }\n    }\n  }\n  if (opt.sameSite) {\n    const sameSite = typeof opt.sameSite === \"string\" ? opt.sameSite.toLowerCase() : opt.sameSite;\n    switch (sameSite) {\n      case true: {\n        str += \"; SameSite=Strict\";\n        break;\n      }\n      case \"lax\": {\n        str += \"; SameSite=Lax\";\n        break;\n      }\n      case \"strict\": {\n        str += \"; SameSite=Strict\";\n        break;\n      }\n      case \"none\": {\n        str += \"; SameSite=None\";\n        break;\n      }\n      default: {\n        throw new TypeError(\"option sameSite is invalid\");\n      }\n    }\n  }\n  if (opt.partitioned) {\n    str += \"; Partitioned\";\n  }\n  return str;\n}\nfunction isDate(val) {\n  return Object.prototype.toString.call(val) === \"[object Date]\" || val instanceof Date;\n}\n\nfunction parseSetCookie(setCookieValue, options) {\n  const parts = (setCookieValue || \"\").split(\";\").filter((str) => typeof str === \"string\" && !!str.trim());\n  const nameValuePairStr = parts.shift() || \"\";\n  const parsed = _parseNameValuePair(nameValuePairStr);\n  const name = parsed.name;\n  let value = parsed.value;\n  try {\n    value = options?.decode === false ? value : (options?.decode || decodeURIComponent)(value);\n  } catch {\n  }\n  const cookie = {\n    name,\n    value\n  };\n  for (const part of parts) {\n    const sides = part.split(\"=\");\n    const partKey = (sides.shift() || \"\").trimStart().toLowerCase();\n    const partValue = sides.join(\"=\");\n    switch (partKey) {\n      case \"expires\": {\n        cookie.expires = new Date(partValue);\n        break;\n      }\n      case \"max-age\": {\n        cookie.maxAge = Number.parseInt(partValue, 10);\n        break;\n      }\n      case \"secure\": {\n        cookie.secure = true;\n        break;\n      }\n      case \"httponly\": {\n        cookie.httpOnly = true;\n        break;\n      }\n      case \"samesite\": {\n        cookie.sameSite = partValue;\n        break;\n      }\n      default: {\n        cookie[partKey] = partValue;\n      }\n    }\n  }\n  return cookie;\n}\nfunction _parseNameValuePair(nameValuePairStr) {\n  let name = \"\";\n  let value = \"\";\n  const nameValueArr = nameValuePairStr.split(\"=\");\n  if (nameValueArr.length > 1) {\n    name = nameValueArr.shift();\n    value = nameValueArr.join(\"=\");\n  } else {\n    value = nameValuePairStr;\n  }\n  return { name, value };\n}\n\nfunction splitSetCookieString(cookiesString) {\n  if (Array.isArray(cookiesString)) {\n    return cookiesString.flatMap((c) => splitSetCookieString(c));\n  }\n  if (typeof cookiesString !== \"string\") {\n    return [];\n  }\n  const cookiesStrings = [];\n  let pos = 0;\n  let start;\n  let ch;\n  let lastComma;\n  let nextStart;\n  let cookiesSeparatorFound;\n  const skipWhitespace = () => {\n    while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n      pos += 1;\n    }\n    return pos < cookiesString.length;\n  };\n  const notSpecialChar = () => {\n    ch = cookiesString.charAt(pos);\n    return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n  };\n  while (pos < cookiesString.length) {\n    start = pos;\n    cookiesSeparatorFound = false;\n    while (skipWhitespace()) {\n      ch = cookiesString.charAt(pos);\n      if (ch === \",\") {\n        lastComma = pos;\n        pos += 1;\n        skipWhitespace();\n        nextStart = pos;\n        while (pos < cookiesString.length && notSpecialChar()) {\n          pos += 1;\n        }\n        if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n          cookiesSeparatorFound = true;\n          pos = nextStart;\n          cookiesStrings.push(cookiesString.slice(start, lastComma));\n          start = pos;\n        } else {\n          pos = lastComma + 1;\n        }\n      } else {\n        pos += 1;\n      }\n    }\n    if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n      cookiesStrings.push(cookiesString.slice(start, cookiesString.length));\n    }\n  }\n  return cookiesStrings;\n}\n\nexport { parse, parseSetCookie, serialize, splitSetCookieString };\n","export function klona(x) {\n\tif (typeof x !== 'object') return x;\n\n\tvar k, tmp, str=Object.prototype.toString.call(x);\n\n\tif (str === '[object Object]') {\n\t\tif (x.constructor !== Object && typeof x.constructor === 'function') {\n\t\t\ttmp = new x.constructor();\n\t\t\tfor (k in x) {\n\t\t\t\tif (x.hasOwnProperty(k) && tmp[k] !== x[k]) {\n\t\t\t\t\ttmp[k] = klona(x[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\ttmp = {}; // null\n\t\t\tfor (k in x) {\n\t\t\t\tif (k === '__proto__') {\n\t\t\t\t\tObject.defineProperty(tmp, k, {\n\t\t\t\t\t\tvalue: klona(x[k]),\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\twritable: true,\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\ttmp[k] = klona(x[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tif (str === '[object Array]') {\n\t\tk = x.length;\n\t\tfor (tmp=Array(k); k--;) {\n\t\t\ttmp[k] = klona(x[k]);\n\t\t}\n\t\treturn tmp;\n\t}\n\n\tif (str === '[object Set]') {\n\t\ttmp = new Set;\n\t\tx.forEach(function (val) {\n\t\t\ttmp.add(klona(val));\n\t\t});\n\t\treturn tmp;\n\t}\n\n\tif (str === '[object Map]') {\n\t\ttmp = new Map;\n\t\tx.forEach(function (val, key) {\n\t\t\ttmp.set(klona(key), klona(val));\n\t\t});\n\t\treturn tmp;\n\t}\n\n\tif (str === '[object Date]') {\n\t\treturn new Date(+x);\n\t}\n\n\tif (str === '[object RegExp]') {\n\t\ttmp = new RegExp(x.source, x.flags);\n\t\ttmp.lastIndex = x.lastIndex;\n\t\treturn tmp;\n\t}\n\n\tif (str === '[object DataView]') {\n\t\treturn new x.constructor( klona(x.buffer) );\n\t}\n\n\tif (str === '[object ArrayBuffer]') {\n\t\treturn x.slice(0);\n\t}\n\n\t// ArrayBuffer.isView(x)\n\t// ~> `new` bcuz `Buffer.slice` => ref\n\tif (str.slice(-6) === 'Array]') {\n\t\treturn new x.constructor(x);\n\t}\n\n\treturn x;\n}\n","import { customRef, getCurrentScope, nextTick, onScopeDispose, ref, watch } from \"vue\";\nimport { parse, serialize } from \"cookie-es\";\nimport { deleteCookie, getCookie, getRequestHeader, setCookie } from \"h3\";\nimport destr from \"destr\";\nimport { isEqual } from \"ohash\";\nimport { klona } from \"klona\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { useRequestEvent } from \"./ssr.js\";\nimport { cookieStore } from \"#build/nuxt.config.mjs\";\nconst CookieDefaults = {\n  path: \"/\",\n  watch: true,\n  decode: (val) => destr(decodeURIComponent(val)),\n  encode: (val) => encodeURIComponent(typeof val === \"string\" ? val : JSON.stringify(val))\n};\nconst store = import.meta.client && cookieStore ? window.cookieStore : void 0;\nexport function useCookie(name, _opts) {\n  const opts = { ...CookieDefaults, ..._opts };\n  opts.filter ??= (key) => key === name;\n  const cookies = readRawCookies(opts) || {};\n  let delay;\n  if (opts.maxAge !== void 0) {\n    delay = opts.maxAge * 1e3;\n  } else if (opts.expires) {\n    delay = opts.expires.getTime() - Date.now();\n  }\n  const hasExpired = delay !== void 0 && delay <= 0;\n  const cookieValue = klona(hasExpired ? void 0 : cookies[name] ?? opts.default?.());\n  const cookie = import.meta.client && delay && !hasExpired ? cookieRef(cookieValue, delay, opts.watch && opts.watch !== \"shallow\") : ref(cookieValue);\n  if (import.meta.dev && hasExpired) {\n    console.warn(`[nuxt] not setting cookie \\`${name}\\` as it has already expired.`);\n  }\n  if (import.meta.client) {\n    let channel = null;\n    try {\n      if (!store && typeof BroadcastChannel !== \"undefined\") {\n        channel = new BroadcastChannel(`nuxt:cookies:${name}`);\n      }\n    } catch {\n    }\n    const callback = () => {\n      if (opts.readonly || isEqual(cookie.value, cookies[name])) {\n        return;\n      }\n      writeClientCookie(name, cookie.value, opts);\n      cookies[name] = klona(cookie.value);\n      channel?.postMessage({ value: opts.encode(cookie.value) });\n    };\n    const handleChange = (data) => {\n      const value = data.refresh ? readRawCookies(opts)?.[name] : opts.decode(data.value);\n      watchPaused = true;\n      cookie.value = value;\n      cookies[name] = klona(value);\n      nextTick(() => {\n        watchPaused = false;\n      });\n    };\n    let watchPaused = false;\n    const hasScope = !!getCurrentScope();\n    if (hasScope) {\n      onScopeDispose(() => {\n        watchPaused = true;\n        callback();\n        channel?.close();\n      });\n    }\n    if (store) {\n      const changeHandler = (event) => {\n        const changedCookie = event.changed.find((c) => c.name === name);\n        const removedCookie = event.deleted.find((c) => c.name === name);\n        if (changedCookie) {\n          handleChange({ value: changedCookie.value });\n        }\n        if (removedCookie) {\n          handleChange({ value: null });\n        }\n      };\n      store.addEventListener(\"change\", changeHandler);\n      if (hasScope) {\n        onScopeDispose(() => store.removeEventListener(\"change\", changeHandler));\n      }\n    } else if (channel) {\n      channel.onmessage = ({ data }) => handleChange(data);\n    }\n    if (opts.watch) {\n      watch(\n        cookie,\n        () => {\n          if (watchPaused) {\n            return;\n          }\n          callback();\n        },\n        { deep: opts.watch !== \"shallow\" }\n      );\n    } else {\n      callback();\n    }\n  } else if (import.meta.server) {\n    const nuxtApp = useNuxtApp();\n    const writeFinalCookieValue = () => {\n      if (opts.readonly || isEqual(cookie.value, cookies[name])) {\n        return;\n      }\n      nuxtApp._cookies ||= {};\n      if (name in nuxtApp._cookies) {\n        if (isEqual(cookie.value, nuxtApp._cookies[name])) {\n          return;\n        }\n        if (import.meta.dev) {\n          console.warn(`[nuxt] cookie \\`${name}\\` was previously set to \\`${opts.encode(nuxtApp._cookies[name])}\\` and is being overridden to \\`${opts.encode(cookie.value)}\\`. This may cause unexpected issues.`);\n        }\n      }\n      nuxtApp._cookies[name] = cookie.value;\n      writeServerCookie(useRequestEvent(nuxtApp), name, cookie.value, opts);\n    };\n    const unhook = nuxtApp.hooks.hookOnce(\"app:rendered\", writeFinalCookieValue);\n    nuxtApp.hooks.hookOnce(\"app:error\", () => {\n      unhook();\n      return writeFinalCookieValue();\n    });\n  }\n  return cookie;\n}\nexport function refreshCookie(name) {\n  if (import.meta.server || store || typeof BroadcastChannel === \"undefined\") {\n    return;\n  }\n  new BroadcastChannel(`nuxt:cookies:${name}`)?.postMessage({ refresh: true });\n}\nfunction readRawCookies(opts = {}) {\n  if (import.meta.server) {\n    return parse(getRequestHeader(useRequestEvent(), \"cookie\") || \"\", opts);\n  } else if (import.meta.client) {\n    return parse(document.cookie, opts);\n  }\n}\nfunction serializeCookie(name, value, opts = {}) {\n  if (value === null || value === void 0) {\n    return serialize(name, value, { ...opts, maxAge: -1 });\n  }\n  return serialize(name, value, opts);\n}\nfunction writeClientCookie(name, value, opts = {}) {\n  if (import.meta.client) {\n    document.cookie = serializeCookie(name, value, opts);\n  }\n}\nfunction writeServerCookie(event, name, value, opts = {}) {\n  if (event) {\n    if (value !== null && value !== void 0) {\n      return setCookie(event, name, value, opts);\n    }\n    if (getCookie(event, name) !== void 0) {\n      return deleteCookie(event, name, opts);\n    }\n  }\n}\nconst MAX_TIMEOUT_DELAY = 2147483647;\nfunction cookieRef(value, delay, shouldWatch) {\n  let timeout;\n  let unsubscribe;\n  let elapsed = 0;\n  const internalRef = shouldWatch ? ref(value) : { value };\n  if (getCurrentScope()) {\n    onScopeDispose(() => {\n      unsubscribe?.();\n      clearTimeout(timeout);\n    });\n  }\n  return customRef((track, trigger) => {\n    if (shouldWatch) {\n      unsubscribe = watch(internalRef, trigger);\n    }\n    function createExpirationTimeout() {\n      elapsed = 0;\n      clearTimeout(timeout);\n      const timeRemaining = delay - elapsed;\n      const timeoutLength = timeRemaining < MAX_TIMEOUT_DELAY ? timeRemaining : MAX_TIMEOUT_DELAY;\n      timeout = setTimeout(() => {\n        elapsed += timeoutLength;\n        if (elapsed < delay) {\n          return createExpirationTimeout();\n        }\n        internalRef.value = void 0;\n        trigger();\n      }, timeoutLength);\n    }\n    return {\n      get() {\n        track();\n        return internalRef.value;\n      },\n      set(newValue) {\n        createExpirationTimeout();\n        internalRef.value = newValue;\n        trigger();\n      }\n    };\n  });\n}\n","import { useCookie, useRoute } from \"#imports\";\nlet showWarning = true;\nexport const useContentPreview = () => {\n  const getPreviewToken = () => {\n    return useCookie(\"previewToken\").value || import.meta.client && sessionStorage.getItem(\"previewToken\") || void 0;\n  };\n  const setPreviewToken = (token) => {\n    useCookie(\"previewToken\").value = token;\n    useRoute().query.preview = token || \"\";\n    if (import.meta.client) {\n      if (token) {\n        sessionStorage.setItem(\"previewToken\", token);\n      } else {\n        sessionStorage.removeItem(\"previewToken\");\n      }\n      window.location.reload();\n    }\n  };\n  const isEnabled = () => {\n    const query = useRoute().query;\n    if (Object.prototype.hasOwnProperty.call(query, \"preview\") && !query.preview) {\n      return false;\n    }\n    if (query.preview || useCookie(\"previewToken\").value) {\n      if (import.meta.dev && showWarning) {\n        console.warn(\"[content] Client DB enabled since a preview token is set (either in query or cookie).\");\n        showWarning = false;\n      }\n      return true;\n    }\n    if (import.meta.client && sessionStorage.getItem(\"previewToken\")) {\n      return true;\n    }\n    return false;\n  };\n  return {\n    isEnabled,\n    getPreviewToken,\n    setPreviewToken\n  };\n};\n"],"names":["parse","str","options","obj","opt","dec","decode","index","eqIdx","endIdx","key","val","tryDecode","decode2","fieldContentRegExp","serialize","name","value","enc","encodedValue","maxAge","isDate","klona","x","k","tmp","CookieDefaults","destr","store","useCookie","_opts","opts","cookies","readRawCookies","delay","hasExpired","cookieValue","_a","cookie","cookieRef","ref","channel","callback","isEqual","writeClientCookie","handleChange","data","watchPaused","nextTick","hasScope","getCurrentScope","onScopeDispose","changeHandler","event","changedCookie","c","removedCookie","watch","serializeCookie","MAX_TIMEOUT_DELAY","shouldWatch","timeout","unsubscribe","elapsed","internalRef","customRef","track","trigger","createExpirationTimeout","timeRemaining","timeoutLength","newValue","useContentPreview","query","useRoute","token"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}